# LCLS
Input is Linac Coherent Light Source image. Calculates hermans, Intensity, and other properties vs q.

A. Main script: tr_LCLS_LG_noA_PLA_dwz20150320. Essentially the same as SAXS_LG_noA_PLA_erm20140123, but modified to process the LCLS data.
  1. Things you need to change between running SAXS data and WAXS data:
    a) line 13: mask path (*saxs* for SAXS, *waxs* for WAXS)
    b) line 15/16: SDD
    c) line 54: scaleloc (~1 for SAXS, ~10 for WAXS)
  2. Masking: I made a SAXS mask and a WAXS mask. They’re stored in the folder Masks. In addition to these pre-made masks, the code is built to treat any zero-valued pixel in the image as part of the mask. The only pixels that are exactly zero-valued are the gaps between panels, which why I chose this criterion.
  3. Other key differences:
    a) saxsi was already a struct, but now it has more fields:
      (1) index: when read_all_images_LCLSmat_masked loads the images from imagerun, they are often out of order. By making this field and then using it to sort saxsi, the code puts the images in the right order
      (2) energy: beamline energy—even though it’s approximately constant
      (3) x, y, z (3 separate fields): sample stage x, y, and z coordinates
    b) instead of pre-specifying the matrix of heights, the code creates it from the list of saxsi.y
  4. read_all_images_LCLSmat_masked (function): Eric wrote read_all_images_LCLSmat. The only thing I added was the line about masking (just after background subtraction).
  5. getCenter (function) and subfunctions: I only changed things that assumed a 1024 x 1024 pixel image. Otherwise it’s the same as before.
  6. find_rmax_v2 (function): see IV. A. 3.
  7. wedge_lineout_masked_strict (function): see wedge_lineout (IV. A. 4.). The only difference is that it takes the sector average internally in order to screen out masked data. That is, it only takes the average of non-zero-valued pixels.
    a) rectslice_masked_strict (function): same as rectslice, only it uses matrixave_masked_strict instead of matrixave
      (1) matrixave_masked_strict (function): when matrixave would take an average of pixels, if any of the pixels it would take an average from are 0, the number matrixave_masked_strict reports is 0.
  8. get_offset_theta_redo (function): same as getCenter—no changes except making it compatible with any image size.
  9. azimuthal_subtract_masked_strict (function): azimuthal_subtract modified to deal with the mask. It uses matrixave_masked_strict, and if any of the pixels at a particular phi coordinate are 0, the value reported for that phi coordinate is 0.
  10. hermans_masked_withfit (function): takes in the output of azimuthal_subtract_masked_strict, fits the curve with a Lorentzian peak to fill the gaps, and calculates hermans
    a) lorentzfit (function): similar to gaussfit, but with a lorentzian peak shape. There are multiple options for background subtraction, none of which are used in this context, as the background is supposed to have already been subtracted.
  11. single_manual_plot_hermans (function): again, modified to the extent necessary to make it compatible with all image sizes. Also, modified to accept new source of height coordinates for z-scans (log.txt).
  12. azimuthal_masked_strict (function): same as azimuthal_subtract_masked_strict—modified from azimuthal (function) to accept masking.
  13. single_manual_plot_fitting (function) and single_manual_plot_nofitting (function): same modifications as single_manual_plot_hermans (function)
B. Auxiliary functions/scripts
  1. create_mask (script): walks you through the process of creating a mask from a series of rectangles
  2. average image stack (function): averages a stack of images in a given directory and saves the averaged images in a separate directory
    a) inputs: input directory, output directory, number of images to average for each averaged image, delimiter in the file name (for LCLS .mat files: ‘_’), prefix in front of image index (for LCLS .mat files: empty ‘’), logical: is the index an integer?
    b) no outputs; things it saves: “outdirec/fileprefix-delim-‘averaged’-delim-prefix-avgindex.mat” where outdirec is the output directory, fileprefix is all the stuff that comes before the index in the original file names, delim is the delimiter, prefix is the indicator that you’ve found the index, and avgindex is the average index of the images averaged into this image.
    c) parse_direc (function): see I.C.1.b) 
    d) im_avg (function): actually does the work of loading the images and averaging. This is done in a subfunction to reduce memory usage. Otherwise, this would be an impossible task.
      (1) inputs: directory, struct with info on filenames (generated by parse_direc)
      (2) outputs: averaged image
